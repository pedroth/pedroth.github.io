(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Pedroth"] = factory();
	else
		root["Pedroth"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Pedroth/Pedroth.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/nabla.js/src/ArrayUtils/main/ArrayUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/nabla.js/src/ArrayUtils/main/ArrayUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ArrayUtils = {};\r\n\r\n/**\r\n * Union of array a1 and a2\r\n * @param {*} a1\r\n * @param {*} a2\r\n */\r\nArrayUtils.concat = function(a1, a2) {\r\n  return a1.concat(a2);\r\n};\r\n\r\n/**\r\n *  Test if linear arrays are equal\r\n * @param {*} a1\r\n * @param {*} a2\r\n */\r\nArrayUtils.arrayEquals = function(a1, a2) {\r\n  if (a1.length != a2.length) return false;\r\n  for (var i = 0; i < a1.length; i++) {\r\n    if (a1[i] != a2[i]) return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Return a new array permutation\r\n * @param {*} array\r\n * @param {*} permutation is an array with length <= array.length that has the new indexes\r\n */\r\nArrayUtils.permute = function(array, permutation) {\r\n  var copy = array.slice();\r\n  var len = Math.min(array.length, permutation.length);\r\n  for (var i = 0; i < len; i++) {\r\n    copy[permutation[i]] = array[i];\r\n  }\r\n  return copy;\r\n};\r\n\r\n/**\r\n * Fisher-Yates shuffle algorithm\r\n */\r\nArrayUtils.randomPermute = function(array) {\r\n  const ans = [...array];\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    // random number between 0 and i\r\n    const r = Math.floor(Math.random() * (i + 1));\r\n    //swap in place\r\n    const temp = ans[i];\r\n    ans[i] = ans[r];\r\n    ans[r] = temp;\r\n  }\r\n  return ans;\r\n};\r\n\r\n/**\r\n * return swap array indexes\r\n */\r\nArrayUtils.swap = function(array, i, j) {\r\n  var t = array[i];\r\n  array[i] = array[j];\r\n  array[j] = t;\r\n  return array;\r\n};\r\n\r\nArrayUtils.findJsArrayDim = function(array) {\r\n  if (array instanceof Array) {\r\n    return ArrayUtils.concat(ArrayUtils.findJsArrayDim(array[0]), [\r\n      array.length\r\n    ]);\r\n  } else {\r\n    return [];\r\n  }\r\n};\r\n\r\nArrayUtils.unpackJsArray = function(array) {\r\n  if (array instanceof Array) {\r\n    var joinIdentity = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      joinIdentity = ArrayUtils.concat(\r\n        joinIdentity,\r\n        ArrayUtils.unpackJsArray(array[i])\r\n      );\r\n    }\r\n    return joinIdentity;\r\n  } else {\r\n    return [array];\r\n  }\r\n};\r\n\r\nArrayUtils.range = function(xmin, xmax, step = 1) {\r\n  var ans = [];\r\n  for (var i = xmin; i < xmax; i += step) ans.push(i);\r\n  return ans;\r\n};\r\n\r\nArrayUtils.binaryOp = function(array1, array2, binaryOp) {\r\n  var smaller = array1.length < array2.length ? array1.slice() : array2.slice();\r\n  for (let i = 0; i < smaller.length; i++)\r\n    smaller[i] = binaryOp(array1[i], array2[i]);\r\n  return smaller;\r\n};\r\n\r\n/**\r\n * Used in general collections\r\n */\r\nArrayUtils.map = function(array, mapFunc) {\r\n  const ans = [];\r\n  for (let i = 0; i < array.length; i++) {\r\n    ans.push(mapFunc(array[i], i));\r\n  }\r\n  return ans;\r\n};\r\n\r\nArrayUtils.filter = function(array, filterFunc) {\r\n  const ans = [];\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (filterFunc(array[i], i)) ans.push(array[i]);\r\n  }\r\n  return ans;\r\n};\r\n\r\nArrayUtils.forEach = function(array, forEachFunc) {\r\n  for (let i = 0; i < array.length; i++) {\r\n    forEachFunc(array[i], i);\r\n  }\r\n};\r\n\r\nmodule.exports = ArrayUtils;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/ArrayUtils/main/ArrayUtils.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Canvas/main/Canvas.js":
/*!*********************************************************!*\
  !*** ./node_modules/nabla.js/src/Canvas/main/Canvas.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ImageIO = __webpack_require__(/*! ./ImageIO.js */ \"./node_modules/nabla.js/src/Canvas/main/ImageIO.js\");\r\n/*\r\n Canvas coordinates\r\n\r\n 0                  W-1\r\n +-------------> y\r\n |\r\n |\r\n |       *\r\n |\r\n |\r\n v x\r\n\r\n H-1\r\n */\r\n\r\n/*\r\nThe canvas data is an array of length colors(C) * width(W) * height(H). Is a 3D-array.\r\nThe index is a number in [0, C * W * H - 1].\r\nHaving (x, y, z) where z is the color axis, the formula to index the array is :\r\n\r\nf(x, y, z) = C * W * x + C * y + z.\r\n\r\nWhere x in [0, H - 1], y in [0, W - 1] and z in [0, C - 1].\r\n\r\nNote that f(H - 1, W - 1, C - 1) = C * W * H - 1.\r\n*/\r\n\r\n// Auxiliary functions\r\nfunction scale(u, r) {\r\n  var ans = [];\r\n  ans[0] = u[0] * r;\r\n  ans[1] = u[1] * r;\r\n  return ans;\r\n}\r\n\r\nfunction add(u, v) {\r\n  var ans = [];\r\n  ans[0] = u[0] + v[0];\r\n  ans[1] = u[1] + v[1];\r\n  return ans;\r\n}\r\n\r\nfunction floor(x) {\r\n  var ans = [];\r\n  ans[0] = Math.floor(x[0]);\r\n  ans[1] = Math.floor(x[1]);\r\n  return ans;\r\n}\r\n\r\nfunction diff(u, v) {\r\n  var ans = [];\r\n  ans[0] = u[0] - v[0];\r\n  ans[1] = u[1] - v[1];\r\n  return ans;\r\n}\r\n\r\nfunction dot(u, v) {\r\n  return u[0] * v[0] + u[1] * v[1];\r\n}\r\n\r\nfunction squareNorm(x) {\r\n  return dot(x, x);\r\n}\r\n\r\nfunction norm(x) {\r\n  return Math.sqrt(dot(x, x));\r\n}\r\n\r\nfunction min(u, v) {\r\n  var ans = [];\r\n  ans[0] = Math.min(u[0], v[0]);\r\n  ans[1] = Math.min(u[1], v[1]);\r\n  return ans;\r\n}\r\n\r\nfunction max(u, v) {\r\n  var ans = [];\r\n  ans[0] = Math.max(u[0], v[0]);\r\n  ans[1] = Math.max(u[1], v[1]);\r\n  return ans;\r\n}\r\n\r\n/**\r\n * return solution to : [ u_0 , h] x = z_0\r\n *\r\n *                       [ u_1,  0] y = z_1\r\n */\r\nfunction solve2by2UpperTriMatrix(u, h, z) {\r\n  var aux = z[1] / u[1];\r\n  return [aux, (-u[0] * aux + z[0]) / h];\r\n}\r\n/**\r\n * return solution to : [ u_0 , 0] x = z_0\r\n *\r\n *                       [ u_1,  w] y = z_1\r\n */\r\nfunction solve2by2LowerTriMatrix(u, w, z) {\r\n  var aux = z[0] / u[0];\r\n  return [aux, (-u[1] * aux + z[1]) / w];\r\n}\r\n\r\n// Canvas\r\nvar Canvas = function(canvas) {\r\n  this.canvas = canvas;\r\n  this.ctx = canvas.getContext(\"2d\");\r\n  this.image = this.ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n  // width * height * 4 array of integers\r\n  this.imageData = this.image.data;\r\n};\r\n\r\n/**\r\n * Returns a two vector with Height as first coordinate and Width as second. [Height, Width].\r\n */\r\nCanvas.prototype.getSize = function() {\r\n  return [this.canvas.height, this.canvas.width];\r\n};\r\n\r\n/**\r\n *  Draw update image on canvas.\r\n */\r\nCanvas.prototype.paintImage = function() {\r\n  this.ctx.putImageData(this.image, 0, 0);\r\n};\r\n\r\nCanvas.prototype.getCanvas = function() {\r\n  return this.canvas;\r\n};\r\n\r\n/**\r\n * Clear Image with @rgba color.\r\n *\r\n * @param rgba\r\n */\r\nCanvas.prototype.clearImage = function(rgba) {\r\n  this.useCanvasCtx(canvas => {\r\n    var size = canvas.getSize();\r\n    canvas.ctx.fillStyle =\r\n      \"rgba(\" + rgba[0] + \",\" + rgba[1] + \",\" + rgba[2] + \",\" + rgba[3] + \")\";\r\n    canvas.ctx.globalCompositeOperation = \"source-over\";\r\n    canvas.ctx.fillRect(0, 0, size[1], size[0]);\r\n  }, true);\r\n};\r\n\r\nCanvas.prototype.useCanvasCtx = function(lambda, isClearImage = false) {\r\n  if (!isClearImage) {\r\n    this.ctx.putImageData(this.image, 0, 0);\r\n  }\r\n  lambda(this);\r\n  this.image = this.ctx.getImageData(\r\n    0,\r\n    0,\r\n    this.canvas.width,\r\n    this.canvas.height\r\n  );\r\n  this.imageData = this.image.data;\r\n};\r\n\r\nCanvas.prototype.getImageIndex = function(x) {\r\n  return 4 * (this.canvas.width * x[0] + x[1]);\r\n};\r\n\r\nCanvas.prototype.getPxl = function(x) {\r\n  var index = this.getImageIndex(x);\r\n  return [\r\n    this.imageData[index],\r\n    this.imageData[index + 1],\r\n    this.imageData[index + 2],\r\n    this.imageData[index + 3]\r\n  ];\r\n};\r\n\r\nCanvas.prototype.drawPxl = function(x, rgb) {\r\n  var index = this.getImageIndex(x);\r\n  this.imageData[index] = rgb[0];\r\n  this.imageData[index + 1] = rgb[1];\r\n  this.imageData[index + 2] = rgb[2];\r\n  this.imageData[index + 3] = rgb[3];\r\n};\r\n\r\n/*\r\n * x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and a line (array with 2 points) and returns a rgba 4-dim array\r\n */\r\nCanvas.prototype.drawLine = function(x1, x2, shader) {\r\n  // add points before clip\r\n  shader.points = [x1, x2];\r\n\r\n  // do clipping\r\n  var stack = [];\r\n  stack.push(x1);\r\n  stack.push(x2);\r\n  var inStack = [];\r\n  var outStack = [];\r\n  for (var i = 0; i < stack.length; i++) {\r\n    var x = stack[i];\r\n    if (\r\n      0 <= x[0] &&\r\n      x[0] < this.canvas.height &&\r\n      0 <= x[1] &&\r\n      x[1] < this.canvas.width\r\n    ) {\r\n      inStack.push(x);\r\n    } else {\r\n      outStack.push(x);\r\n    }\r\n  }\r\n  // both points are inside canvas\r\n  if (inStack.length == 2) {\r\n    this.drawLineInt(inStack[0], inStack[1], shader);\r\n    return;\r\n  }\r\n  //intersecting line with canvas\r\n  var intersectionSolutions = [];\r\n  var v = [x2[0] - x1[0], x2[1] - x1[1]];\r\n  // Let s \\in [0,1]\r\n  // line intersection with [0, 0]^T + [H - 1, 0]^T s\r\n  intersectionSolutions.push(\r\n    solve2by2UpperTriMatrix(v, -(this.canvas.height - 1), [-x1[0], -x1[1]])\r\n  );\r\n  // line intersection with [H - 1, 0]^T + [0, W - 1]^T s\r\n  intersectionSolutions.push(\r\n    solve2by2LowerTriMatrix(v, -(this.canvas.width - 1), [\r\n      this.canvas.height - 1 - x1[0],\r\n      -x1[1]\r\n    ])\r\n  );\r\n  // line intersection with [H - 1, W - 1]^T + [-(H - 1), 0]^T s\r\n  intersectionSolutions.push(\r\n    solve2by2UpperTriMatrix(v, this.canvas.height - 1, [\r\n      this.canvas.height - 1 - x1[0],\r\n      this.canvas.width - 1 - x1[1]\r\n    ])\r\n  );\r\n  // line intersection with [0, W - 1]^T + [0, -(W - 1)]^T s\r\n  intersectionSolutions.push(\r\n    solve2by2LowerTriMatrix(v, this.canvas.width - 1, [\r\n      -x1[0],\r\n      this.canvas.width - 1 - x1[1]\r\n    ])\r\n  );\r\n\r\n  var validIntersection = [];\r\n  for (var i = 0; i < intersectionSolutions.length; i++) {\r\n    var x = intersectionSolutions[i];\r\n    if (0 <= x[0] && x[0] <= 1 && 0 <= x[1] && x[1] <= 1) {\r\n      validIntersection.push(x);\r\n    }\r\n  }\r\n\r\n  if (validIntersection.length == 0) return;\r\n\r\n  //it can be shown that at this point there is at least one valid intersection.\r\n  if (inStack.length > 0) {\r\n    var p = [\r\n      x1[0] + validIntersection[0][0] * v[0],\r\n      x1[1] + validIntersection[0][0] * v[1]\r\n    ];\r\n    this.drawLineInt(inStack.pop(), p, shader);\r\n    return;\r\n  }\r\n\r\n  var p0 = [\r\n    x1[0] + validIntersection[0][0] * v[0],\r\n    x1[1] + validIntersection[0][0] * v[1]\r\n  ];\r\n  for (var i = 1; i < validIntersection.length; i++) {\r\n    var p = [\r\n      x1[0] + validIntersection[i][0] * v[0],\r\n      x1[1] + validIntersection[i][0] * v[1]\r\n    ];\r\n    var v = diff(p, p0);\r\n    if (dot(v, v) > 1e-3) {\r\n      this.drawLineInt(p0, p, shader);\r\n      return;\r\n    }\r\n  }\r\n  this.drawLineInt(p0, p0, shader);\r\n};\r\n\r\nCanvas.prototype.drawLineInt = function(x1, x2, shader) {\r\n  x1 = floor(x1);\r\n  x2 = floor(x2);\r\n\r\n  var index = [-1, 0, 1];\r\n\r\n  var n = index.length;\r\n  var nn = n * n;\r\n\r\n  var x = [];\r\n  x[0] = x1[0];\r\n  x[1] = x1[1];\r\n\r\n  var tangent = diff(x2, x1);\r\n  var normal = [];\r\n  normal[0] = -tangent[1];\r\n  normal[1] = tangent[0];\r\n\r\n  shader(x, shader.points, this);\r\n\r\n  while (x[0] !== x2[0] || x[1] !== x2[1]) {\r\n    var fmin = Number.MAX_VALUE;\r\n    var minDir = [];\r\n    for (var k = 0; k < nn; k++) {\r\n      var i = index[k % n];\r\n      var j = index[Math.floor(k / n)];\r\n\r\n      var nextX = add(x, [i, j]);\r\n\r\n      var v = diff(nextX, x1);\r\n      var f = Math.abs(dot(v, normal)) - dot(v, tangent);\r\n      if (fmin > f) {\r\n        fmin = f;\r\n        minDir = [i, j];\r\n      }\r\n    }\r\n\r\n    x = add(x, minDir);\r\n    shader(x, shader.points, this);\r\n  }\r\n  shader(x, shader.points, this);\r\n};\r\n\r\nCanvas.prototype.drawPolygon = function(\r\n  array,\r\n  shader,\r\n  isInsidePoly = Canvas.isInsidePolygon\r\n) {\r\n  let upperBox = [\r\n    [Number.MAX_VALUE, Number.MAX_VALUE],\r\n    [Number.MIN_VALUE, Number.MIN_VALUE]\r\n  ];\r\n  for (let i = 0; i < array.length; i++) {\r\n    upperBox[0] = min(array[i], upperBox[0]);\r\n    upperBox[1] = max(array[i], upperBox[1]);\r\n  }\r\n\r\n  let size = this.getSize();\r\n  let clampedSize = diff(size, [1, 1]);\r\n  let zeros = [0, 0];\r\n  upperBox[0] = floor(min(clampedSize, max(zeros, upperBox[0])));\r\n  upperBox[1] = floor(min(clampedSize, max(zeros, upperBox[1])));\r\n\r\n  for (var i = upperBox[0][0]; i < upperBox[1][0]; i++) {\r\n    for (var j = upperBox[0][1]; j < upperBox[1][1]; j++) {\r\n      var x = [i, j];\r\n      if (isInsidePoly(x, array)) {\r\n        shader(x, array, this);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/*\r\n * x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * x3     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and a triangle (array with 3 points) and returns a rgba 4-dim array\r\n */\r\nCanvas.prototype.drawTriangle = function(x1, x2, x3, shader) {\r\n  var array = [x1, x2, x3];\r\n  this.drawPolygon(array, shader, Canvas.isInsideConvex);\r\n};\r\n\r\n/* x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * x3     :   2-dim array\r\n * x4     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and returns a rgba 4-dim array\r\n */\r\nCanvas.prototype.drawQuad = function(x1, x2, x3, x4, shader) {\r\n  this.drawPolygon([x1, x2, x3, x4], shader);\r\n};\r\n\r\nCanvas.prototype.drawImage = function(img, x) {\r\n  if (\"isReady\" in img && !img.isReady) return;\r\n  this.useCanvasCtx(canvas => canvas.ctx.drawImage(img, x[1], x[0]));\r\n};\r\n\r\nCanvas.prototype.drawCircle = function(x, r, shader) {\r\n  var corner = scale([1, 1], r);\r\n  var upperBox = [diff(x, corner), add(x, corner)];\r\n  var size = this.getSize();\r\n  upperBox[0] = floor(min(diff(size, [1, 1]), max([0, 0], upperBox[0])));\r\n  upperBox[1] = floor(min(diff(size, [1, 1]), max([0, 0], upperBox[1])));\r\n  for (var i = upperBox[0][0]; i <= upperBox[1][0]; i++) {\r\n    for (var j = upperBox[0][1]; j <= upperBox[1][1]; j++) {\r\n      var p = [i, j];\r\n      if (this.isInsideCircle(p, x, r)) {\r\n        shader(p, [x, r], this);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nCanvas.prototype.isInsideCircle = function(p, x, r) {\r\n  return squareNorm(diff(p, x)) <= r * r;\r\n};\r\n\r\nCanvas.prototype.addEventListener = function(key, lambda, useCapture) {\r\n  this.canvas.addEventListener(key, lambda, useCapture);\r\n};\r\n\r\nCanvas.prototype.drawString = function(x, string, contextShader) {\r\n  this.useCanvasCtx(canvas => {\r\n    contextShader(canvas.ctx);\r\n    canvas.ctx.fillText(string, x[1], x[0]);\r\n  });\r\n};\r\n\r\n// Static functions\r\n\r\n// slower than isInsideConvex method\r\nCanvas.isInsidePolygon = function(x, array) {\r\n  var v = [];\r\n  var theta = 0;\r\n  var n = array.length;\r\n  for (var i = 0; i < n; i++) {\r\n    v[0] = diff(array[(i + 1) % n], x);\r\n    v[1] = diff(array[i], x);\r\n    theta += Math.acos(dot(v[0], v[1]) / (norm(v[0]) * norm(v[1])));\r\n  }\r\n  return Math.abs(theta - 2 * Math.PI) < 1e-3;\r\n};\r\n\r\nCanvas.isInsideConvex = function(x, array) {\r\n  var m = array.length;\r\n  var v = [];\r\n  var vDotN = [];\r\n  for (var i = 0; i < m; i++) {\r\n    v[i] = diff(array[(i + 1) % m], array[i]);\r\n    let n = [-v[i][1], v[i][0]];\r\n    let r = diff(x, array[i]);\r\n    vDotN[i] = dot(r, n);\r\n  }\r\n  let orientation = v[0][0] * v[1][1] - v[0][1] * v[1][0] > 0 ? 1 : -1;\r\n  for (var i = 0; i < m; i++) {\r\n    var myDot = vDotN[i] * orientation;\r\n    if (myDot < 0) return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nCanvas.simpleShader = function(color) {\r\n  return (x, element, canvas) => canvas.drawPxl(x, color);\r\n};\r\n\r\nCanvas.colorShader = function(colors) {\r\n  var auxShader = (x, poly, canvas, alpha) => {\r\n    var interpolateColors = [0, 0, 0, 0];\r\n    for (var i = 0; i < poly.length; i++) {\r\n      interpolateColors[0] = interpolateColors[0] + colors[i][0] * alpha[i];\r\n      interpolateColors[1] = interpolateColors[1] + colors[i][1] * alpha[i];\r\n      interpolateColors[2] = interpolateColors[2] + colors[i][2] * alpha[i];\r\n      interpolateColors[3] = interpolateColors[3] + colors[i][3] * alpha[i];\r\n    }\r\n    canvas.drawPxl(x, interpolateColors);\r\n  };\r\n  return Canvas.interpolateTriangleShader(auxShader);\r\n};\r\n\r\nCanvas.interpolateQuadShader = function(shader) {\r\n  return function(x, quad, canvas) {\r\n    var t1 = [quad[0], quad[1], quad[2]];\r\n    var t2 = [quad[2], quad[3], quad[0]];\r\n    var alpha = Canvas.triangleBaryCoord(x, t1);\r\n    if (\r\n      alpha[0] > 0 &&\r\n      alpha[1] > 0 &&\r\n      alpha[2] > 0 &&\r\n      Math.abs(alpha[0] + alpha[1] + alpha[2] - 1) < 1e-10\r\n    ) {\r\n      shader(x, quad, canvas, [alpha[0], alpha[1], alpha[2], 0]);\r\n    } else {\r\n      alpha = Canvas.triangleBaryCoord(x, t2);\r\n      shader(x, quad, canvas, [alpha[2], 0, alpha[0], alpha[1]]);\r\n    }\r\n  };\r\n};\r\n\r\nCanvas.interpolateTriangleShader = function(shader) {\r\n  return (x, triangle, canvas) => {\r\n    alpha = Canvas.triangleBaryCoord(x, triangle);\r\n    shader(x, triangle, canvas, alpha);\r\n  };\r\n};\r\n\r\nCanvas.interpolateLineShader = function(shader) {\r\n  return (x, line, canvas) => {\r\n    var v = diff(line[1], line[0]);\r\n    var z = diff(x, line[0]);\r\n    var vnorm = squareNorm(v);\r\n    var projection = dot(z, v);\r\n    var t = vnorm == 0.0 ? 0 : projection / vnorm;\r\n    shader(x, line, canvas, t);\r\n  };\r\n};\r\n\r\n/**\r\n * img: html loaded image.\r\n * quadTexCoord: [0, 1]^{2 * 4}, texture coordinates\r\n */\r\nCanvas.quadTextureShader = function(\r\n  img,\r\n  quadTexCoord,\r\n  interpolation = Canvas.bilinearInterpolation\r\n) {\r\n  let imageCache = null;\r\n  const imageShader = (x, quad, canvas, alpha) => {\r\n    if (!img.isReady || imageCache == null)\r\n      imageCache = new Canvas(ImageIO.getImageCanvas(img));\r\n    const imageCanvas = imageCache;\r\n    const imgSize = imageCanvas.getSize();\r\n    const interpolateTexCoord = [0, 0];\r\n    for (let i = 0; i < quadTexCoord.length; i++) {\r\n      interpolateTexCoord[0] =\r\n        interpolateTexCoord[0] + quadTexCoord[i][0] * alpha[i];\r\n      interpolateTexCoord[1] =\r\n        interpolateTexCoord[1] + quadTexCoord[i][1] * alpha[i];\r\n    }\r\n    var i = [\r\n      (1 - interpolateTexCoord[1]) * (imgSize[1] - 1),\r\n      (imgSize[0] - 1) * interpolateTexCoord[0]\r\n    ];\r\n    // bound coordinates\r\n    i = max([0, 0], min(diff([imgSize[0], imgSize[1]], [1, 1]), i));\r\n    // pxl lower corner\r\n    var j = floor(i);\r\n    var cornerColors = [\r\n      imageCanvas.getPxl(j),\r\n      imageCanvas.getPxl(add(j, [1, 0])),\r\n      imageCanvas.getPxl(add(j, [1, 1])),\r\n      imageCanvas.getPxl(add(j, [0, 1]))\r\n    ];\r\n    var finalColor = interpolation(cornerColors, diff(i, j));\r\n    canvas.drawPxl(x, finalColor);\r\n  };\r\n  return Canvas.interpolateQuadShader(imageShader);\r\n};\r\n\r\nCanvas.triangleCache = (() => {\r\n  const hashMap = [];\r\n  const size = 3;\r\n  return {\r\n    constains: triangleHash => hashMap[triangleHash % size] != undefined,\r\n    get: triangleHash => hashMap[triangleHash % size],\r\n    set: (triangleHash, value) => (hashMap[triangleHash % size] = value)\r\n  };\r\n})(); //{triangle: null, u: [], v:[], det:null, hash:null}\r\n\r\nCanvas.triangleHash = triangle => {\r\n  const array = [\r\n    triangle[0][0],\r\n    triangle[1][0],\r\n    triangle[2][0],\r\n    triangle[0][1],\r\n    triangle[1][1],\r\n    triangle[2][1]\r\n  ];\r\n  return array.reduce((h, x) => 31 * h + x, 1);\r\n};\r\n\r\nCanvas.triangleBaryCoord = function(x, triangle) {\r\n  const hash = Canvas.triangleHash(triangle);\r\n  const y = [x[0] - triangle[0][0], x[1] - triangle[0][1]];\r\n  if (!Canvas.triangleCache.constains(hash)) {\r\n    const u = [\r\n      triangle[1][0] - triangle[0][0],\r\n      triangle[1][1] - triangle[0][1]\r\n    ];\r\n    const v = [\r\n      triangle[2][0] - triangle[0][0],\r\n      triangle[2][1] - triangle[0][1]\r\n    ];\r\n    const det = u[0] * v[1] - u[1] * v[0];\r\n    Canvas.triangleCache.set(hash, {\r\n      triangle: triangle,\r\n      u: u.map(x => x / det),\r\n      v: v.map(x => x / det),\r\n      det: det,\r\n      hash: hash\r\n    });\r\n  }\r\n  const cache = Canvas.triangleCache.get(hash);\r\n  const u = cache.u;\r\n  const v = cache.v;\r\n  const det = cache.det;\r\n  if (det == 0) return [0, 0, 0];\r\n  var alpha = [v[1] * y[0] - v[0] * y[1], u[0] * y[1] - u[1] * y[0]];\r\n  return [1 - alpha[0] - alpha[1], alpha[0], alpha[1]];\r\n};\r\n\r\n/**\r\n * values \\in R^{k * 4}\r\n * x \\in [0,1]^2\r\n */\r\nCanvas.bilinearInterpolation = function(values, x) {\r\n  var acc = [];\r\n  for (var k = 0; k < values.length; k++) {\r\n    var f03 = values[0][k] + (values[3][k] - values[0][k]) * x[1];\r\n    var f12 = values[1][k] + (values[2][k] - values[1][k]) * x[1];\r\n    var f = f03 + (f12 - f03) * x[0];\r\n    acc.push(f);\r\n  }\r\n  return acc;\r\n};\r\n/**\r\n * size: is an array with width and height of a HTML5 Canvas.\r\n * domId: DOM element where the canvas will be added\r\n *\r\n * returns Canvas object from the generated html canvas.\r\n */\r\nCanvas.createCanvas = function(size, domId) {\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.setAttribute(\"width\", size[0]);\r\n  canvas.setAttribute(\"height\", size[1]);\r\n  document.getElementById(domId).appendChild(canvas);\r\n  return canvas;\r\n};\r\n\r\nmodule.exports = Canvas;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Canvas/main/Canvas.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Canvas/main/Canvas2D.js":
/*!***********************************************************!*\
  !*** ./node_modules/nabla.js/src/Canvas/main/Canvas2D.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Canvas = __webpack_require__(/*! ./Canvas.js */ \"./node_modules/nabla.js/src/Canvas/main/Canvas.js\");\r\n\r\n//Note that we can switch from heritage to composition, think about that\r\n\r\n// cameraSpace : 2-dim array with two 2-dim arrays that are intervals [a,b] | a < b\r\nvar Canvas2D = function(canvas, cameraSpace) {\r\n\tCanvas.call(this, canvas);\r\n\tif(cameraSpace.length != 2 || (cameraSpace[0].length != 2 && cameraSpace[1].length != 2)) {\r\n\t\tthrow \"camera space must be 2-dim array with 2-dim arrays representing an interval\";\r\n\t}\r\n\tthis.cameraSpace = cameraSpace;\r\n}\r\n\r\nCanvas2D.prototype = Object.create(Canvas.prototype);\r\nCanvas2D.prototype.constructor = Canvas2D;\r\n\r\n/* x : 2-dim array in camera space coordinates\r\n * returns : 2-dim array in integer coordinates\r\n */\r\nCanvas2D.prototype.integerTransform = function(x) {\r\n\tvar xint = -( this.canvas.height - 1)  / (this.cameraSpace[1][1] - this.cameraSpace[1][0]) * (x[1] - this.cameraSpace[1][1]);\r\n\tvar yint =   ( this.canvas.width - 1)  / (this.cameraSpace[0][1] - this.cameraSpace[0][0]) * (x[0] - this.cameraSpace[0][0]);\r\n\treturn [xint, yint];\r\n}\r\n\r\n/* x : 2-dim array in integer coordinates\r\n * returns : 2-dim array in camera space coordinates\r\n */\r\nCanvas2D.prototype.inverseTransform = function(x) {\r\n\tvar xt = this.cameraSpace[0][0] + (this.cameraSpace[0][1] - this.cameraSpace[0][0]) / (this.canvas.width - 1)  * x[1];\r\n\tvar yt = this.cameraSpace[1][1] - (this.cameraSpace[1][1] - this.cameraSpace[1][0]) / (this.canvas.height - 1) * x[0];\r\n\treturn [xt, yt];\r\n}\r\n\r\n/* x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and returns a rgba 4-dim array\r\n */\r\nCanvas2D.prototype.drawLine = function(x1, x2, shader) {\r\n\ty1 = this.integerTransform(x1);\r\n\ty2 = this.integerTransform(x2);\r\n\tCanvas.prototype.drawLine.call(this, y1, y2, shader);\r\n}\r\n\r\n/* x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * x3     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and returns a rgba 4-dim array\r\n */\r\nCanvas2D.prototype.drawTriangle = function(x1, x2, x3, shader) {\r\n\ty1 = this.integerTransform(x1);\r\n\ty2 = this.integerTransform(x2);\r\n\ty3 = this.integerTransform(x3);\r\n\tCanvas.prototype.drawTriangle.call(this, y1, y2, y3, shader);\r\n}\r\n\r\n/* x1     :   2-dim array\r\n * x2     :   2-dim array\r\n * x3     :   2-dim array\r\n * x4     :   2-dim array\r\n * shader :   is a function that receives a 2-dim array and returns a rgba 4-dim array\r\n */\r\nCanvas2D.prototype.drawQuad = function(x1, x2, x3, x4, shader) {\r\n\ty1 = this.integerTransform(x1);\r\n\ty2 = this.integerTransform(x2);\r\n\ty3 = this.integerTransform(x3);\r\n\ty4 = this.integerTransform(x4);\r\n\tCanvas.prototype.drawQuad.call(this, y1, y2, y3, y4, shader);\r\n}\r\n\r\nCanvas2D.prototype.drawCircle = function(x, r, shader) {\r\n    // it assumes squared canvas, for now ...\r\n    y = this.integerTransform(x);\r\n    z = this.integerTransform([r, 0])[1] - this.integerTransform([0, 0])[1];\r\n    Canvas.prototype.drawCircle.call(this, y, z, shader);\r\n}\r\n\r\nCanvas2D.prototype.drawImage = function (img, x) {\r\n    Canvas.prototype.drawImage.call(this, img, this.integerTransform(x));\r\n}\r\n\r\nCanvas2D.prototype.drawString = function(x, string, contextShader) {\r\n    y = this.integerTransform(x);\r\n    Canvas.prototype.drawString.call(this, y, string, contextShader);\r\n};\r\n\r\n// camera : 2-dim array with two 2-dim arrays that are intervals [a,b] | a < b\r\nCanvas2D.prototype.setCamera = function(camera) {\r\n    if(camera.length != 2 || (camera[0].length != 2 && camera[1].length != 2)) {\r\n\t\tthrow \"camera space must be 2-dim array with 2-dim arrays representing an interval\";\r\n\t}\r\n\tthis.cameraSpace = camera;\r\n}\r\n\r\n\r\nmodule.exports = Canvas2D;\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Canvas/main/Canvas2D.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Canvas/main/ImageIO.js":
/*!**********************************************************!*\
  !*** ./node_modules/nabla.js/src/Canvas/main/ImageIO.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ImageIO = {\r\n    // empty object\r\n};\r\n\r\n/**\r\n * img : html image\r\n */\r\nImageIO.getImageCanvas = function(img) {\r\n    var canvasAux = document.createElement('canvas');\r\n    canvasAux.width = img.width;\r\n    canvasAux.height = img.height;\r\n    var contextAux = canvasAux.getContext('2d');\r\n    contextAux.fillStyle = 'rgba(0, 0, 0, 0)';\r\n    contextAux.globalCompositeOperation = 'source-over';\r\n    contextAux.fillRect(0, 0, canvasAux.width, canvasAux.height);\r\n    contextAux.drawImage(img, 0 ,0);\r\n    return canvasAux;\r\n}\r\n\r\n/**\r\n * img : html image\r\n */\r\nImageIO.getDataFromImage = function(img) {\r\n    canvas = ImageIO.getImageCanvas(img);\r\n    return canvas.getContext('2d').getImageData(0 , 0, img.width, img.height);\r\n};\r\n\r\nImageIO.loadImage = function(src) {\r\n    var img = new Image();\r\n    img.src = src;\r\n    img.isReady = false;\r\n    img.onload = () => img.isReady = true;\r\n    return img;\r\n};\r\n\r\nImageIO.generateImageReadyPredicate = function(img) {\r\n    return () => img.isReady;\r\n}\r\n\r\nmodule.exports = ImageIO;\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Canvas/main/ImageIO.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Function/main/Function.js":
/*!*************************************************************!*\
  !*** ./node_modules/nabla.js/src/Function/main/Function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Function = function(f) {\r\n  this.f = f;\r\n};\r\n\r\nFunction.prototype.compose = function(g) {\r\n  return new Function(x => this.f(g(x)));\r\n};\r\n\r\nFunction.prototype.leftCompose = function(g) {\r\n  return new Function(x => g(this.f(x)));\r\n};\r\n\r\nFunction.prototype.apply = function(x) {\r\n  return this.f(x);\r\n};\r\n\r\nFunction.prototype.get = function() {\r\n  return this.f;\r\n};\r\n\r\nFunction.of = function(f) {\r\n  return new Function(f);\r\n};\r\n\r\nmodule.exports = Function;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Function/main/Function.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Nabla/nabla.js":
/*!**************************************************!*\
  !*** ./node_modules/nabla.js/src/Nabla/nabla.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Canvas = __webpack_require__(/*! ../Canvas/main/Canvas.js */ \"./node_modules/nabla.js/src/Canvas/main/Canvas.js\");\r\nconst Canvas2D = __webpack_require__(/*! ../Canvas/main/Canvas2D.js */ \"./node_modules/nabla.js/src/Canvas/main/Canvas2D.js\");\r\nconst ImageIO = __webpack_require__(/*! ../Canvas/main/ImageIO.js */ \"./node_modules/nabla.js/src/Canvas/main/ImageIO.js\");\r\nconst Stream = __webpack_require__(/*! ../Stream/main/Stream.js */ \"./node_modules/nabla.js/src/Stream/main/Stream.js\");\r\nconst ArrayUtils = __webpack_require__(/*! ../ArrayUtils/main/ArrayUtils */ \"./node_modules/nabla.js/src/ArrayUtils/main/ArrayUtils.js\");\r\nconst Sort = __webpack_require__(/*! ../Sort/main/Sort */ \"./node_modules/nabla.js/src/Sort/main/Sort.js\");\r\n\r\nconst Nabla = {};\r\n\r\nNabla.Canvas = Canvas;\r\nNabla.Canvas2D = Canvas2D;\r\nNabla.ImageIO = ImageIO;\r\nNabla.Stream = Stream;\r\nNabla.ArrayUtils = ArrayUtils;\r\nNabla.Sort = Sort;\r\n\r\nmodule.exports = Nabla;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Nabla/nabla.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Sort/main/Sort.js":
/*!*****************************************************!*\
  !*** ./node_modules/nabla.js/src/Sort/main/Sort.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Sort = {};\r\n\r\nfunction swap(v, i, j) {\r\n  if (i >= 0 && i < v.length && j >= 0 && j < v.length) {\r\n    var temp = v[i];\r\n    v[i] = v[j];\r\n    v[j] = temp;\r\n  }\r\n}\r\n\r\n/**\r\n * array: array with objects\r\n * comparator: comparator function that compares elements of v. Comparator is a function f(a,b) -> z in integers, where z < 0\r\n */\r\nSort.quicksort = function(array, comparator = (a, b) => a - b) {\r\n  const n = array.length;\r\n  const v = [...array];\r\n  const stack = [];\r\n  stack.push(0);\r\n  stack.push(n - 1);\r\n  while (stack.length > 0) {\r\n    const high = stack.pop();\r\n    const low = stack.pop();\r\n    /*\r\n     * partition\r\n     */\r\n    if (low < high) {\r\n      const pivot = low + Math.floor((high - low) * Math.random());\r\n      const pvalue = v[pivot];\r\n      swap(v, pivot, high);\r\n      let j = low;\r\n      for (let i = low; i < high; i++) {\r\n        if (comparator(v[i], pvalue) <= 0) {\r\n          swap(v, i, j);\r\n          j++;\r\n        }\r\n      }\r\n      swap(v, j, high);\r\n      stack.push(low);\r\n      stack.push(j - 1);\r\n      stack.push(j + 1);\r\n      stack.push(high);\r\n    }\r\n  }\r\n  return v;\r\n};\r\n\r\nSort.REVERSE_SORT_COMPARATOR = (a, b) => b - a;\r\n\r\nmodule.exports = Sort;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Sort/main/Sort.js?");

/***/ }),

/***/ "./node_modules/nabla.js/src/Stream/main/Stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/nabla.js/src/Stream/main/Stream.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Function = __webpack_require__(/*! ../../Function/main/Function.js */ \"./node_modules/nabla.js/src/Function/main/Function.js\");\r\n/**\r\n * The Stream constructor\r\n * @param {*} generator is an object that implements hasNext(), next() and peek() functions and have a initial state\r\n * @param {*} mapFunction the mapping function\r\n */\r\nvar Stream = function(\r\n  generator,\r\n  mapFunction = x => x,\r\n  filterPredicate = x => true\r\n) {\r\n  this.gen = generator;\r\n  this.mapFunction = mapFunction;\r\n  this.filterPredicate = filterPredicate;\r\n};\r\n\r\n/**\r\n * Gets the state of the generator.\r\n */\r\nStream.prototype.state = function() {\r\n  return this.gen.state;\r\n};\r\n\r\n/**\r\n * Returns true if stream has more elements, false otherwise.\r\n */\r\nStream.prototype.hasNext = function() {\r\n  return this.gen.hasNext(this.filteredState());\r\n};\r\n\r\n/**\r\n * Return next filtered state.\r\n */\r\nStream.prototype.filteredState = function() {\r\n  var state = this.state();\r\n  while (\r\n    this.gen.hasNext(state) &&\r\n    !this.filterPredicate(this.gen.peek(state))\r\n  ) {\r\n    state = this.gen.next(state);\r\n  }\r\n  return state;\r\n};\r\n\r\n/**\r\n * Gets first element of the generator, filtered.\r\n */\r\nStream.prototype.head = function() {\r\n  let state = this.filteredState();\r\n  if (this.gen.hasNext(state)) return this.gen.peek(state);\r\n  throw `No head element exception`;\r\n};\r\n\r\n/**\r\n * Gets stream without the first element.\r\n */\r\nStream.prototype.tail = function() {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      this.gen.next(this.filteredState()),\r\n      this.gen.next,\r\n      this.gen.peek,\r\n      this.gen.hasNext\r\n    ),\r\n    this.mapFunction,\r\n    this.filterPredicate\r\n  );\r\n};\r\n\r\n/**\r\n * Returns stream with mapping function f\r\n * @param {*} f, mapping function.\r\n */\r\nStream.prototype.map = function(f) {\r\n  return new Stream(\r\n    this.gen,\r\n    Function.of(f)\r\n      .compose(this.mapFunction)\r\n      .get(),\r\n    this.filterPredicate\r\n  );\r\n};\r\n\r\n/**\r\n * Reducing operation.\r\n * @param {*} identity, identity of binaryOperation used as initial value.\r\n * @param {*} binaryOp, binary operation of the reduce.\r\n */\r\nStream.prototype.reduce = function(identity, binaryOp) {\r\n  var stream = this;\r\n  while (stream.hasNext()) {\r\n    let value = stream.head();\r\n    identity = binaryOp(identity, stream.mapFunction(value));\r\n    stream = stream.tail();\r\n  }\r\n  return identity;\r\n};\r\n/**\r\n * ForEach function on stream\r\n * @param {*} consumer: is a x => void function\r\n */\r\nStream.prototype.forEach = function(consumer) {\r\n  var stream = this;\r\n  while (stream.hasNext()) {\r\n    let value = stream.head();\r\n    consumer(stream.mapFunction(value));\r\n    stream = stream.tail();\r\n  }\r\n};\r\n\r\n/**\r\n *\r\n * @param {*} collector: is an object with the identity, and reduce attributes\r\n *\r\n *  The collector.reduce is a \\lambda (identity, acc) => identity.\r\n */\r\nStream.prototype.collect = function(collector) {\r\n  return this.reduce(collector.identity, collector.reduce);\r\n};\r\n\r\n/**\r\n * @param {*} predicate is a \\lambda (x) => {true, false}\r\n * This function choses the elementes where predicate(x) = true\r\n */\r\nStream.prototype.filter = function(predicate) {\r\n  return new Stream(\r\n    this.gen,\r\n    this.mapFunction,\r\n    x => this.filterPredicate(x) && predicate(x)\r\n  );\r\n};\r\n\r\n/**\r\n * Take first n elements\r\n */\r\nStream.prototype.take = function(n) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      { i: 0, stream: this },\r\n      s => {\r\n        return { i: s.i + 1, stream: s.stream.tail() };\r\n      },\r\n      s => s.stream.head(),\r\n      s => s.stream.hasNext() && s.i < n\r\n    ),\r\n    this.mapFunction,\r\n    this.filterPredicate\r\n  ).collect(Stream.Collectors.toArray());\r\n};\r\n\r\nStream.prototype.takeWhile = function(predicate) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      this,\r\n      s => s.tail(),\r\n      s => s.head(),\r\n      s => s.hasNext() && predicate(s.head())\r\n    ),\r\n    this.mapFunction,\r\n    this.filterPredicate\r\n  ).collect(Stream.Collectors.toArray());\r\n};\r\n\r\nStream.prototype.zip = function(stream) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      [this, stream],\r\n      s => [s[0].tail(), s[1].tail()],\r\n      s => [s[0].head(), s[1].head()],\r\n      s => s[0].hasNext() && s[1].hasNext()\r\n    )\r\n  );\r\n};\r\n\r\nStream.prototype.flatMap = function(toStreamLambda) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      { baseStream: this, flatStream: null },\r\n      s => {\r\n        if (!s.flatStream || !s.flatStream.hasNext()) {\r\n          let stream = s.baseStream;\r\n          return {\r\n            baseStream: stream.tail(),\r\n            flatStream: toStreamLambda(stream.head()).tail()\r\n          };\r\n        }\r\n        return { baseStream: s.baseStream, flatStream: s.flatStream.tail() };\r\n      },\r\n      s => {\r\n        if (!s.flatStream || !s.flatStream.hasNext()) {\r\n          return toStreamLambda(s.baseStream.head()).head();\r\n        }\r\n        return s.flatStream.head();\r\n      },\r\n      s => {\r\n        if (!s.flatStream) {\r\n          return (\r\n            s.baseStream.hasNext() &&\r\n            toStreamLambda(s.baseStream.head()).hasNext()\r\n          );\r\n        }\r\n        return s.baseStream.hasNext() || s.flatStream.hasNext();\r\n      }\r\n    )\r\n  );\r\n};\r\n\r\nStream.ofHeadTail = function(head, tailSupplier) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      { h: head, supplier: tailSupplier },\r\n      s => {\r\n        let stream = s.supplier();\r\n        if (stream.hasNext())\r\n          return { h: stream.head(), supplier: () => stream.tail() };\r\n        // empty state\r\n        return { h: null, supplier: null };\r\n      },\r\n      s => s.h,\r\n      s => s.h != null\r\n    )\r\n  );\r\n};\r\n\r\nStream.of = function(iterable) {\r\n  var types = [\r\n    { name: \"Array\", predicate: x => x.constructor === Array },\r\n    {\r\n      name: \"Generator\",\r\n      predicate: x =>\r\n        typeof x.hasNext === \"function\" &&\r\n        typeof x.next === \"function\" &&\r\n        typeof x.peek == \"function\"\r\n    },\r\n    { name: \"Stream\", predicate: x => x.__proto__ == Stream.prototype }\r\n  ];\r\n  var types2GeneratorMap = {\r\n    Array: ite =>\r\n      new Stream(\r\n        Stream.generatorOf(\r\n          { i: 0, array: ite },\r\n          s => {\r\n            return { i: s.i + 1, array: s.array };\r\n          },\r\n          s => s.array[s.i],\r\n          s => s.i < s.array.length\r\n        )\r\n      ),\r\n    Generator: ite => new Stream(ite),\r\n    Stream: ite => new Stream(ite.gen, ite.mapFunction, ite.filterPredicate)\r\n  };\r\n  for (let i = 0; i < types.length; i++) {\r\n    if (types[i].predicate(iterable)) {\r\n      return types2GeneratorMap[types[i].name](iterable);\r\n    }\r\n  }\r\n  throw `Iterable ${iterable} does not have a stream`;\r\n};\r\n\r\nStream.range = function(init, end, step = 1) {\r\n  return new Stream(\r\n    Stream.generatorOf(\r\n      init,\r\n      s => s + step,\r\n      s => s,\r\n      s => (end == null ? true : s < end)\r\n    )\r\n  );\r\n};\r\n\r\nStream.generatorOf = function(\r\n  initialState,\r\n  nextStateFunction,\r\n  getFromStateFunction,\r\n  hasNextStateFunction\r\n) {\r\n  return new (function() {\r\n    this.state = initialState;\r\n    this.next = nextStateFunction;\r\n    this.peek = getFromStateFunction;\r\n    this.hasNext = hasNextStateFunction;\r\n  })();\r\n};\r\n\r\nStream.Collectors = {\r\n  toArray: () =>\r\n    new (function() {\r\n      this.identity = [];\r\n      this.reduce = (acc, x) => {\r\n        acc.push(x);\r\n        return acc;\r\n      };\r\n    })()\r\n};\r\nmodule.exports = Stream;\r\n\n\n//# sourceURL=webpack://Pedroth/./node_modules/nabla.js/src/Stream/main/Stream.js?");

/***/ }),

/***/ "./src/Card/Card.js":
/*!**************************!*\
  !*** ./src/Card/Card.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Card = {};\r\n\r\n/**\r\n * @param data: {imageSrc: string, url: string, title: string, tags: array<string>, date: string}\r\n */\r\nCard.createCardFromData = data => {\r\n  console.log(\"Create Card From Data\", data);\r\n  return DomBuilder.of(\"div\")\r\n    .attr(\"class\", \"card simplePaper\")\r\n    .append(createImage(data))\r\n    .append(createBody(data))\r\n    .build();\r\n};\r\n\r\nmodule.exports = Card;\r\n\r\n//========================================================================================\r\n/*                                                                                      *\r\n *                                   Private functions                                  *\r\n *                                                                                      */\r\n//========================================================================================\r\n\r\nconst createImage = data =>\r\n  DomBuilder.of(\"a\")\r\n    .attr(\"href\", data.url)\r\n    .append(\r\n      DomBuilder.of(\"img\")\r\n        .attr(\"class\", \"card-img-top card-plugin\")\r\n        .attr(\"src\", data.imageSrc)\r\n        .attr(\"href\", data.url)\r\n        .attr(\"alt\", data.title)\r\n        .build()\r\n    )\r\n    .build();\r\n\r\nconst createTitle = data =>\r\n  DomBuilder.of(\"a\")\r\n    .attr(\"href\", data.url)\r\n    .append(\r\n      DomBuilder.of(\"h3\")\r\n        .attr(\"class\", \"card-title title\")\r\n        .inner(data.title)\r\n        .build()\r\n    )\r\n    .build();\r\n\r\nconst createTags = tags =>\r\n  tags.map(tag =>\r\n    DomBuilder.of(\"a\")\r\n      .attr(\"class\", \"badge badge-light\")\r\n      .attr(\"href\", `/?q=${tag}`)\r\n      .inner(tag)\r\n      .build()\r\n  );\r\n\r\nconst createBody = data =>\r\n  DomBuilder.of(\"div\")\r\n    .attr(\"class\", \"card-body\")\r\n    .append(createTitle(data))\r\n    .append(\r\n      DomBuilder.of(\"div\")\r\n        .append(createTags(data.tags))\r\n        .build()\r\n    )\r\n    .append(\r\n      DomBuilder.of(\"p\")\r\n        .attr(\"class\", \"border-top\")\r\n        .inner(data.date)\r\n        .build()\r\n    )\r\n    .build();\r\n\n\n//# sourceURL=webpack://Pedroth/./src/Card/Card.js?");

/***/ }),

/***/ "./src/DomBuilder/main/DomBuilder.js":
/*!*******************************************!*\
  !*** ./src/DomBuilder/main/DomBuilder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class DomBuilder {\r\n  constructor(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  attr(name, value) {\r\n    this.element.setAttribute(name, value);\r\n    return this;\r\n  }\r\n\r\n  append(element) {\r\n    const defaultAction = e => this.element.appendChild(e);\r\n    const type2ActionMap = {\r\n      Array: e => e.forEach(x => this.append(x)),\r\n      [this.constructor.name]: e => this.element.appendChild(e.build())\r\n    };\r\n    const type = element.constructor.name;\r\n\r\n    if (type in type2ActionMap) type2ActionMap[type](element);\r\n    else defaultAction(element);\r\n\r\n    return this;\r\n  }\r\n\r\n  inner(value) {\r\n    this.element.innerHTML = value;\r\n    return this;\r\n  }\r\n\r\n  removeChildren() {\r\n    while (this.element.firstChild) {\r\n      this.element.removeChild(this.element.lastChild);\r\n    }\r\n  }\r\n\r\n  html(value) {\r\n    return this.inner(value);\r\n  }\r\n\r\n  event(eventName, lambda) {\r\n    this.element.addEventListener(eventName, lambda);\r\n    return this;\r\n  }\r\n\r\n  build() {\r\n    return this.element;\r\n  }\r\n\r\n  /**\r\n   * @param {*} elem: string || element\r\n   */\r\n  static of(elem) {\r\n    if (isElement(elem)) {\r\n      return new DomBuilder(elem);\r\n    }\r\n    return new DomBuilder(document.createElement(elem));\r\n  }\r\n\r\n  static ofId(id) {\r\n    return new DomBuilder(document.getElementById(id));\r\n  }\r\n}\r\n\r\n//Returns true if it is a DOM element\r\nfunction isElement(o) {\r\n  return typeof HTMLElement === \"object\"\r\n    ? o instanceof HTMLElement //DOM2\r\n    : o &&\r\n        typeof o === \"object\" &&\r\n        o !== null &&\r\n        o.nodeType === 1 &&\r\n        typeof o.nodeName === \"string\";\r\n}\r\n\r\nmodule.exports = DomBuilder;\r\n\n\n//# sourceURL=webpack://Pedroth/./src/DomBuilder/main/DomBuilder.js?");

/***/ }),

/***/ "./src/Pedroth/Pedroth.js":
/*!********************************!*\
  !*** ./src/Pedroth/Pedroth.js ***!
  \********************************/
/*! exports provided: DomBuilder, WebUtils, Card, Nabla, SearchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomBuilder\", function() { return DomBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebUtils\", function() { return WebUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Card\", function() { return Card; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Nabla\", function() { return Nabla; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SearchInput\", function() { return SearchInput; });\nconst DomBuilder = __webpack_require__(/*! ../DomBuilder/main/DomBuilder */ \"./src/DomBuilder/main/DomBuilder.js\");\r\nconst WebUtils = __webpack_require__(/*! ../WebUtils/WebUtils */ \"./src/WebUtils/WebUtils.js\");\r\nconst Card = __webpack_require__(/*! ../Card/Card */ \"./src/Card/Card.js\");\r\nconst Nabla = __webpack_require__(/*! nabla.js */ \"./node_modules/nabla.js/src/Nabla/nabla.js\");\r\nconst SearchInput = __webpack_require__(/*! ../SearchInput/SearchInput */ \"./src/SearchInput/SearchInput.js\");\r\n\r\n\r\n\n\n//# sourceURL=webpack://Pedroth/./src/Pedroth/Pedroth.js?");

/***/ }),

/***/ "./src/SearchInput/SearchInput.js":
/*!****************************************!*\
  !*** ./src/SearchInput/SearchInput.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// const DomBuilder = require(\"../DomBuilder/main/DomBuilder\");\r\n// const uuid = key => `${key}${Math.random()}`;\r\n// const range = a => b => (a < b ? [a].concat(range(a + 1)(b)) : []);\r\n// const range0 = range(0);\r\n// const mod = n => i => (n + (i % n)) % n;\r\n\r\n// class SearchInput {\r\n//   static defaultProps = {\r\n//     onClick: input => {},\r\n//     onChange: (input, searchBar) => {\r\n//       searchBar.setSuggestions(range0(10).map(Math.random));\r\n//     },\r\n//     inputDom: DomBuilder.of(\"input\").build(),\r\n//     buttonDom: DomBuilder.of(\"button\")\r\n//       .inner(\"search\")\r\n//       .build()\r\n//   };\r\n\r\n//   constructor(props) {\r\n//     this.props = { ...SearchInput.defaultProps, ...props };\r\n//     this.id = uuid(\"id\");\r\n//     this.idInput = uuid(\"id\");\r\n//     this.idSuggestion = uuid(\"id\");\r\n//     this.domComponent = this.buildDOMComponent();\r\n//     // not selected\r\n//     this.selectedIndex = null;\r\n//     this.inputValue = \"\";\r\n//     this.suggestionList = [];\r\n//   }\r\n\r\n//   getDOM = () => this.domComponent;\r\n\r\n//   buildDOMComponent = () =>\r\n//     DomBuilder.of(\"div\")\r\n//       .attr(\"id\", this.id)\r\n//       .append(this.getInput())\r\n//       .append(this.getButton())\r\n//       .build();\r\n\r\n//   getInput = () =>\r\n//     DomBuilder.of(this.props.inputDom)\r\n//       .attr(\"id\", this.idInput)\r\n//       .event(\"input\", e => {\r\n//         this.inputValue = e.target.value;\r\n//         this.props.onChange(this.inputValue, this);\r\n//         this.render();\r\n//       })\r\n//       .event(\"keydown\", evt => {\r\n//         console.log(\"Key pressed\");\r\n//         const keyCodeAction = {\r\n//           13: this.props.onClick,\r\n//           38: this.highLightNextSuggestion(-1),\r\n//           40: this.highLightNextSuggestion(1)\r\n//         };\r\n//         const action = keyCodeAction[evt.keyCode];\r\n//         action && action(this.inputValue);\r\n//       });\r\n\r\n//   highLightNextSuggestion = step => () => {\r\n//     if (this.selectedIndex == null) {\r\n//       this.highLightIndex(0);\r\n//     } else {\r\n//       this.highLightIndex(\r\n//         mod(this.suggestionList.length)(this.selectedIndex + step)\r\n//       );\r\n//     }\r\n//   };\r\n\r\n//   highLightIndex = index => {\r\n//     const domSuggestions = DomBuilder.ofId(this.idSuggestion).build()\r\n//       .children[0].children;\r\n\r\n//     const arrayDomSuggestions = Array.from(domSuggestions);\r\n//     arrayDomSuggestions.forEach(dom => (dom.style = \"\"));\r\n\r\n//     const domSuggestionIndex = arrayDomSuggestions.filter(\r\n//       (dom, i) => index === i\r\n//     );\r\n\r\n//     this.selectedIndex = index;\r\n//     if (index === null) return;\r\n\r\n//     DomBuilder.ofId(this.idInput).build().value = this.suggestionList[index];\r\n//     this.inputValue = this.suggestionList[index];\r\n//     domSuggestionIndex.forEach(dom => (dom.style = this.highLightStyle));\r\n//   };\r\n\r\n//   highLightStyle =\r\n//     \"background-color:rgba(100, 100, 100); color:rgb(255,255,255);\";\r\n\r\n//   getButton = () =>\r\n//     DomBuilder.of(this.props.buttonDom).event(\"click\", () =>\r\n//       this.props.onClick(this.inputValue)\r\n//     );\r\n\r\n//   render = () => {\r\n//     console.log(\"Render\", this.selectedIndex);\r\n//     this.renderSuggestions();\r\n//   };\r\n\r\n//   renderSuggestions = () => {\r\n//     if (!document.getElementById(this.idSuggestion)) {\r\n//       DomBuilder.of(document.body).append(\r\n//         DomBuilder.of(\"div\").attr(\"id\", this.idSuggestion)\r\n//       );\r\n//     }\r\n//     DomBuilder.ofId(this.idSuggestion).removeChildren();\r\n//     const box = this.getSearchBox();\r\n//     DomBuilder.ofId(this.idSuggestion)\r\n//       .append(\r\n//         DomBuilder.of(\"ul\")\r\n//           .attr(\"class\", \"list-group\")\r\n//           .append(this.suggestionList.map(this.createCard))\r\n//       )\r\n//       .attr(\r\n//         \"style\",\r\n//         `position: absolute; top:${box.y + box.height}px; left: ${\r\n//           box.x\r\n//         }px; width: ${box.width}`\r\n//       );\r\n//   };\r\n\r\n//   createCard = (suggestion, index) =>\r\n//     DomBuilder.of(\"li\")\r\n//       .attr(\"style\", index === this.selectedIndex ? this.highLightStyle : \"\")\r\n//       .attr(\"class\", \"list-group-item\")\r\n//       .event(\"click\", () => {\r\n//         DomBuilder.ofId(this.idInput).build().value = suggestion;\r\n//         this.inputValue = suggestion;\r\n//         DomBuilder.ofId(this.idSuggestion).removeChildren();\r\n//       })\r\n//       .event(\"mouseover\", evt => {\r\n//         console.log(\"Mouse over\", index);\r\n//         this.highLightIndex(index);\r\n//       })\r\n//       .event(\"mouseout\", evt => {\r\n//         this.highLightIndex(null);\r\n//       })\r\n//       .html(suggestion);\r\n\r\n//   getSearchBox = () =>\r\n//     DomBuilder.ofId(this.idInput)\r\n//       .build()\r\n//       .getBoundingClientRect();\r\n\r\n//   setSuggestions = suggestionList => (this.suggestionList = suggestionList);\r\n// }\r\n\r\n// module.exports = SearchInput;\r\n\n\n//# sourceURL=webpack://Pedroth/./src/SearchInput/SearchInput.js?");

/***/ }),

/***/ "./src/WebUtils/WebUtils.js":
/*!**********************************!*\
  !*** ./src/WebUtils/WebUtils.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Sort, ArrayUtils } = __webpack_require__(/*! nabla.js */ \"./node_modules/nabla.js/src/Nabla/nabla.js\");\r\n\r\nconst WebUtils = {};\r\n\r\nWebUtils.retrieveAndAppend = async function(url, htmlId) {\r\n  console.log(`Reading from ${url}.. appending on ${htmlId}`);\r\n  const html = await fetch(url).then(x => x.text());\r\n  $(`#${htmlId}`).html(html);\r\n  /**\r\n   * We have to use jquery to run <script> tags in html, vanilla js doesn't work.\r\n   * vanilla js: document.getElementById(htmlId).innerHTML = html;\r\n   * jquery does some processing to the innerHTML string\r\n   */\r\n};\r\n\r\nWebUtils.readDb = async function() {\r\n  const time = new Date().getTime();\r\n  if (!localStorage.db || time - localStorage.db.time > TIME2UPDATE_MILLIS) {\r\n    const dbJson = await fetch(\"resources/db/db.json\").then(x => x.json());\r\n    localStorage.db = JSON.stringify({ time: time, data: dbJson });\r\n  }\r\n  return JSON.parse(localStorage.db).data;\r\n};\r\n\r\nWebUtils.sortDb = function(db) {\r\n  return Sort.quicksort(\r\n    db.experiments,\r\n    (a, b) => date2int(a.date) - date2int(b.date) < 0\r\n  );\r\n};\r\n\r\nWebUtils.randomDb = function(db) {\r\n  return ArrayUtils.randomPermute(db.experiments);\r\n};\r\n\r\nmodule.exports = WebUtils;\r\n\r\n//========================================================================================\r\n/*                                                                                      *\r\n *                                   Private functions                                  *\r\n *                                                                                      */\r\n//========================================================================================\r\n\r\nfunction date2int(date) {\r\n  var dateStrs = date.split(\"/\");\r\n  var acm = 0;\r\n  var ide = 1;\r\n  for (var j = 0; j < dateStrs.length; j++) {\r\n    acm += parseFloat(dateStrs[j]) * ide;\r\n    ide *= 100;\r\n  }\r\n  return acm;\r\n}\r\n\r\nconst TIME2UPDATE_MILLIS = 24 * 3.6e3 * 1e3; // one day in millis;\r\n\n\n//# sourceURL=webpack://Pedroth/./src/WebUtils/WebUtils.js?");

/***/ })

/******/ });
});