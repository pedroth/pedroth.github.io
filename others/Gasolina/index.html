<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gasolina Casa -- Mov.ai</title>
    <style>
        html {
            text-align: center;
        }

        table {
            font-size: x-large;
            border-collapse: collapse;
            width: 100%;
            border: 1px solid #ddd;
        }

        table input {
            font-size: larger;
        }

        th,
        td {
            text-align: left;
            padding: 16px;
        }
    </style>
</head>

<body></body>
<script>
    function just(x) {
        return { map: f => maybe(f(x)), orSome: z => x }
    }

    function none(x) {
        return { map: _ => none(), orSome: z => z }
    }

    function maybe(x) {
        if (!!x) {
            return just(x);
        }
        return none(x)
    }

    class Mul {
        constructor(left, right) {
            this.left = left;
            this.left.parent = [...(this.left.parent || []), this];
            this.right = right;
            this.right.parent = [...(this.right.parent || []), this];
        }

        mul(node) {
            if (!isNaN(node)) return new Mul(this, new Constant(node));
            return new Mul(this, node);
        }

        div(node) {
            if (!isNaN(node)) return new Div(this, new Constant(node));
            return new Div(this, node);
        }

        compute() {
            return this.left.compute() * this.right.compute();
        }

        toString() {
            return `(${this.left.toString()} * ${this.right.toString()})`;
        }

        render() {
            const span = document.createElement("span")
            this.dom = span;
            span.innerText = this.compute();
            return span;
        }

        updateRender() {
            this.parent && this.parent.forEach(p => p.updateRender())
            if (this.dom) {
                this.dom.innerText = this.compute();
            }
            return this;
        }

        simplify() {
            const simpleLeft = this.left.simplify()
            const simpleRight = this.right.simplify()
            if (simpleLeft instanceof Constant && simpleRight instanceof Constant) {
                return new Constant(simpleLeft.compute() * simpleRight.compute())
            }
            return new Mul(simpleLeft, simpleRight);
        }
    }

    class Div {
        constructor(left, right) {
            this.left = left;
            this.left.parent = [...(this.left.parent || []), this];
            this.right = right;
            this.right.parent = [...(this.right.parent || []), this];
        }

        mul(node) {
            if (!isNaN(node)) return new Mul(this, new Constant(node));
            return new Mul(this, node);
        }

        div(node) {
            if (!isNaN(node)) return new Div(this, new Constant(node));
            return new Div(this, node);
        }

        compute() {
            return this.left.compute() / this.right.compute();
        }

        toString() {
            return `(${this.left.toString()} / ${this.right.toString()})`;
        }

        render() {
            const span = document.createElement("span")
            this.dom = span;
            span.innerText = this.compute();
            return span;
        }

        updateRender() {
            this.parent && this.parent.forEach(p => p.updateRender())
            if (this.dom) {
                this.dom.innerText = this.compute();
            }
            return this;
        }

        simplify() {
            const simpleLeft = this.left.simplify()
            const simpleRight = this.right.simplify()
            if (simpleLeft instanceof Constant && simpleRight instanceof Constant) {
                return new Constant(simpleLeft.compute() / simpleRight.compute())
            }
            return new Div(simpleLeft, simpleRight);
        }
    }

    class Constant {
        constructor(value) {
            this.value = value;
        }

        mul(node) {
            if (!isNaN(node)) return new Mul(this, new Constant(node));
            return new Mul(this, node);
        }

        div(node) {
            if (!isNaN(node)) return new Div(this, new Constant(node));
            return new Div(this, node);
        }

        compute() {
            return this.value;
        }

        toString() {
            return `${this.value}`;
        }

        render() {
            const span = document.createElement("span")
            this.dom = span;
            span.innerText = this.compute();
            return span;
        }

        updateRender() {
            // constant values don't change, hence no need to upadate dom
            return this;
        }

        simplify() {
            return this;
        }
    }

    class Variable {
        constructor(symbol, value) {
            this.symbol = symbol;
            this.value = value;
        }

        mul(node) {
            if (!isNaN(node)) return new Mul(this, new Constant(node));
            return new Mul(this, node);
        }

        div(node) {
            if (!isNaN(node)) return new Div(this, new Constant(node));
            return new Div(this, node);
        }

        compute() {
            return this.value;
        }

        toString() {
            return `${this.symbol}`;
        }

        render() {
            const numberInput = document.createElement("input")
            numberInput.setAttribute("type", "number")
            numberInput.setAttribute("min", 0)
            numberInput.setAttribute("step",
                maybe(Number(this.value).toString().split("."))
                    .map(x => x[1])
                    .map(x => 1 / Math.pow(10, x.length))
                    .orSome(1)
            )
            numberInput.onchange = (e) => {
                this.value = Number(e.target.value);
                console.log("debug variable on change", this.value)
                this.parent && this.parent.forEach(p => p.updateRender())
                this.updateRender();
            }
            numberInput.value = this.compute()
            this.dom = numberInput;
            return numberInput;
        }

        updateRender() {
            if (this.dom) {
                this.dom.value = this.compute();
            }
            return this;
        }

        simplify() {
            return this;
        }
    }

    function getExplainedTable() {
        const numeroDePessoas = new Variable("n", 3);
        const consumoMedioLitro100Km = new Constant(7.7);
        const consumoMedioLitroKm = consumoMedioLitro100Km.div(100);
        const distanciaCasaMovai = new Constant(26.8);
        const distanciaCasaMovaiDouble = distanciaCasaMovai.mul(2);
        const preçoGasolina = new Variable("x", 1.763);
        const preçoFinal = preçoGasolina
            .mul(distanciaCasaMovaiDouble)
            .mul(consumoMedioLitroKm);
        const preçoFinalShared = preçoFinal.simplify().div(numeroDePessoas);
        const table = {
            "Nº pessoas": numeroDePessoas,
            "Consumo médio (l/100km)": consumoMedioLitro100Km,
            "Consumo médio (l/km)": consumoMedioLitroKm,
            "Distância Casa -> Movai (km)": distanciaCasaMovai,
            "2x Distância Casa -> Movai (km)": distanciaCasaMovaiDouble,
            "Preço da Gasolina (€/l)": preçoGasolina,
            "Preço Final €": preçoFinal,
            "Preço Final € / Nº Pessoas": preçoFinalShared
        };
        const explainTable = document.createElement("table");
        Object.keys(table).forEach(key => {
            const line = document.createElement("tr");
            const columnItem1 = document.createElement("td");
            columnItem1.innerText = key;
            line.appendChild(columnItem1);

            const columnItem2 = document.createElement("td");
            const str = table[key].toString();
            columnItem2.innerText = str.includes("(")
                ? str.slice(1, str.length - 1)
                : str;
            line.appendChild(columnItem2);
            explainTable.appendChild(line);

            const columnItem3 = document.createElement("td");
            columnItem3.appendChild(table[key].render());
            line.appendChild(columnItem3);
            explainTable.appendChild(line);
        });
        return explainTable;
    }

    function getGasolineWidget() {
        const div = document.createElement("div");
        const widget = document.createElement("div");
        widget.id = "maisgasolina-widget";
        widget.setAttribute("data-theme", 1);
        widget.onload = () => {
            console.log("onload widget");
        };
        div.appendChild(widget);
        const widgetScript = document.createElement("script");
        widgetScript.setAttribute(
            "src",
            "//static.maisgasolina.com/widget/mg.js"
        );
        widgetScript.setAttribute("async", true);
        div.appendChild(widgetScript);
        return div;
    }

    (async () => {
        const header = document.createElement("h1");
        header.innerText = "Custos da Viagem (Casa < == > Movai)";
        document.body.appendChild(header);
        document.body.appendChild(getGasolineWidget());
        document.body.appendChild(getExplainedTable())
    })();
</script>

</html>